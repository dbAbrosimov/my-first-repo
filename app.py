import streamlit as st
import io
import logging
import plotly.express as px

from db import init_db, fetch_metrics, update_metric

from parser import load_data, get_types
from analysis import (
    prepare_table,
    analyze_pairs,
    compute_delta_optx,
    pretty,
)

logging.basicConfig(level=logging.DEBUG)

# Expand page width
st.set_page_config(layout="wide")


# Initialize database and load metric info
init_db()
metrics_df = fetch_metrics()


def get_group(metric_pretty_name):
    row = metrics_df.loc[metrics_df['metric'] == metric_pretty_name]
    if not row.empty:
        return row.iloc[0]['group_name']
    return 'other'


def get_agg_rules():
    return dict(zip(metrics_df['metric'], metrics_df['agg_func']))


# buffer for in-app logs
log_buffer = io.StringIO()
buffer_handler = logging.StreamHandler(log_buffer)
buffer_handler.setLevel(logging.DEBUG)
logging.getLogger().addHandler(buffer_handler)

# list for collecting debug messages
log_messages = []

with st.sidebar.expander('–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∞–º–∏'):
    metric_names = metrics_df['metric'].tolist()
    if metric_names:
        selected = st.selectbox('–ú–µ—Ç—Ä–∏–∫–∞', metric_names)
        current = metrics_df.set_index('metric').loc[selected]
        new_group = st.selectbox(
            '–ì—Ä—É–ø–ø–∞',
            ['activity', 'sleep', 'body', 'cardio', 'metabolism', 'workout', 'other'],
            index=['activity', 'sleep', 'body', 'cardio', 'metabolism', 'workout', 'other'].index(current['group_name']) if current['group_name'] in ['activity', 'sleep', 'body', 'cardio', 'metabolism', 'workout', 'other'] else 0,
        )
        new_agg = st.selectbox('–ê–≥—Ä–µ–≥–∞—Ü–∏—è', ['sum', 'mean'], index=0 if current['agg_func'] == 'sum' else 1)
        if st.button('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è'):
            update_metric(selected, new_group, new_agg)
            metrics_df = fetch_metrics()
            st.success('–û–±–Ω–æ–≤–ª–µ–Ω–æ')


st.title("Health XML: –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–µ—Ç—Ä–∏–∫")

uploaded = st.file_uploader("–ó–∞–≥—Ä—É–∑–∏—Ç–µ Apple Health XML", type="xml")
if not uploaded:
    st.stop()
file_bytes = uploaded.read()

types = get_types(file_bytes)


st.sidebar.markdown("### –ú–µ—Ç—Ä–∏–∫–∞ X (–¥–µ–Ω—å)")
x_type = st.sidebar.selectbox(
    "–û—Å—å X",
    types,
    index=(
        types.index("HKQuantityTypeIdentifierStepCount")
        if "HKQuantityTypeIdentifierStepCount" in types
        else 0
    ),
)

st.sidebar.markdown("### –ú–µ—Ç—Ä–∏–∫–∞ Y (–Ω–æ—á—å)")
y_type = st.sidebar.selectbox(
    "–û—Å—å Y",
    types,
    index=(
        types.index("HKCategoryTypeIdentifierSleepAnalysis")
        if "HKCategoryTypeIdentifierSleepAnalysis" in types
        else 0
    ),
)

# –í—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∞ –∞–≥—Ä–µ–≥–∞—Ü–∏–∏
period = st.sidebar.selectbox("–ì—Ä–∞–Ω—É–ª—è—Ä–Ω–æ—Å—Ç—å", ["–î–µ–Ω—å", "–ù–µ–¥–µ–ª—è", "–ú–µ—Å—è—Ü"])
# –ü–æ—Ä–æ–≥ p-value
p_thr = st.sidebar.slider(
    "–ü–æ—Ä–æ–≥ –∑–Ω–∞—á–∏–º–æ—Å—Ç–∏ p-value", min_value=0.01, max_value=0.1, value=0.05, step=0.01
)

# Option to exclude trivial same-group pairs
drop_same = st.sidebar.checkbox("–ò—Å–∫–ª—é—á–∏—Ç—å –ø–∞—Ä—ã –∏–∑ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã", value=True)

# Vectorized workflow
raw_df = load_data(file_bytes)

wide_df = prepare_table(raw_df, period, get_agg_rules())

# determine min_N threshold: median observations per metric or 10
min_N = max(10, int(wide_df.notna().sum().median()))
pairs_df = analyze_pairs(wide_df, p_thr, min_N)


if not pairs_df.empty:
    df2 = compute_delta_optx(wide_df, pairs_df.copy())
    df2['X'] = df2['X_raw'].map(pretty)
    df2['Y'] = df2['Y_raw'].map(pretty)

    # format p-value to three decimal places

    def fmt_p(p):
        # format p-value to three decimal places
        return f"{p:.3f}"

    df2["p"] = df2["p"].apply(fmt_p)

    if drop_same:
        diff_mask = df2['X'].map(get_group) != df2['Y'].map(get_group)
        df2 = df2[diff_mask].reset_index(drop=True)

    # –ü–æ–∏—Å–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ
    search = st.text_input("üîç –ü–æ–∏—Å–∫ –º–µ—Ç—Ä–∏–∫ (X –∏–ª–∏ Y)", "")
    if search:
        mask = df2["X"].str.contains(search, case=False) | df2["Y"].str.contains(
            search, case=False
        )
        df_display = df2.loc[mask]
    else:
        df_display = df2
    st.dataframe(df_display[["X", "Y", "r", "p", "ŒîY", "OptX", "N"]])

    # –¢–æ–ø –º–µ–∂–≥—Ä—É–ø–ø–æ–≤—ã—Ö —Å–≤—è–∑–µ–π

    if st.sidebar.checkbox('–ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–ø-5 –º–µ–∂–≥—Ä—É–ø–ø–æ–≤—ã—Ö —Å–≤—è–∑–µ–π –ø–æ |r|', value=False):
        cross_mask = df2['X'].map(get_group) != df2['Y'].map(get_group)
        cross_df = df2[cross_mask].copy()
        # —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–º—É r –∏ –±–µ—Ä—ë–º —Ç–æ–ø-5
        cross_df["abs_r"] = cross_df["r"].abs()
        top5 = cross_df.sort_values("abs_r", ascending=False).head(5)
        st.subheader("–¢–æ–ø-5 —Å–≤—è–∑–µ–π –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ –≥—Ä—É–ø–ø–∞–º–∏")
        st.dataframe(
            top5[["X", "Y", "r", "p", "N", "ŒîY", "OptX"]], use_container_width=True
        )
else:
    st.write("–ù–µ—Ç –∑–Ω–∞—á–∏–º—ã—Ö —Å–≤—è–∑–µ–π –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞ p-value.")

# Interactive description per row
with st.expander("–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ"):
    selected_row_index = st.number_input(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞",
        min_value=0,
        max_value=len(df2) - 1 if not pairs_df.empty else 0,
        step=1,
        value=0,
    )
    if not pairs_df.empty and 0 <= selected_row_index < len(df2):
        row = df2.iloc[selected_row_index]
        st.write(f"**–ü–∞—Ä–∞–º–µ—Ç—Ä X:** {row['X']} (–æ—Ä–∏–≥–∏–Ω–∞–ª: {row['X_raw']})")
        st.write(f"**–ü–∞—Ä–∞–º–µ—Ç—Ä Y:** {row['Y']} (–æ—Ä–∏–≥–∏–Ω–∞–ª: {row['Y_raw']})")
        st.write(f"**–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ (r):** {row['r']:.3f}")
        st.write(f"**p-–∑–Ω–∞—á–µ–Ω–∏–µ:** {row['p']}")
        st.write(f"**–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π (N):** {row['N']}")
        st.write(f"**–°—Ä–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ ŒîY:** {row['ŒîY']:.3f}")
        st.write(f"**–û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ X (–≥–¥–µ Y >= 95% max):** {row['OptX']}")
        # Plot scatter
        orig_X = row["X_raw"]
        orig_Y = row["Y_raw"]
        series = wide_df[[orig_X, orig_Y]].dropna()
        # Compute and display average and expected benefit
        mean_x = series[orig_X].mean()
        mean_y = series[orig_Y].mean()
        threshold = 0.95 * series[orig_Y].max()
        expected_benefit = threshold - mean_y
        st.write(f"–°–µ–π—á–∞—Å –≤–∞—à —Å—Ä–µ–¥–Ω–∏–π **{row['X']}** ‚âà {mean_x:.1f}.")
        st.write(
            f"–ü—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ –¥–æ **{row['OptX']:.1f}** –≤–∞—à —Å—Ä–µ–¥–Ω–∏–π **{row['Y']}** –º–æ–∂–µ—Ç –≤—ã—Ä–∞—Å—Ç–∏ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ {expected_benefit:.1f}."
        )
        fig = px.scatter(
            series,
            x=orig_X,
            y=orig_Y,
            title=f"–ì—Ä–∞—Ñ–∏–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ {row['Y']} –æ—Ç {row['X']}",
            labels={orig_X: row['X'], orig_Y: row['Y']}
        )
        st.plotly_chart(fig, use_container_width=True)
